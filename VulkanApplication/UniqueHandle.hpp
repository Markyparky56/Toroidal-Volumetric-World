#pragma once
// UniqueHandle class, based on the class of the same name from Vulkan.hpp
// Vulkan.hpp is Copyright The Khronos Group Inc.
// Vulkan.hpp is licensed under the Apache License, Version 2.0
// You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
// Vulkan.hpp carries some exceptions to Apache 2.0 License which are listed below:
// ---- Exceptions to the Apache 2.0 License: ----
// 
// As an exception, if you use this Software to generate code and portions of
// this Software are embedded into the generated code as a result, you may
// redistribute such product without providing attribution as would otherwise
// be required by Sections 4(a), 4(b) and 4(d) of the License.
// 
// In addition, if you combine or link code generated by this Software with
// software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
// ("`Combined Software`") and if a court of competent jurisdiction determines
// that the patent provision (Section 3), the indemnity provision (Section 9)
// or other Section of the License conflicts with the conditions of the
// applicable GPL or LGPL license, you may retroactively and prospectively
// choose to deem waived or otherwise exclude such Section(s) of the License,
// but only in their entirety and only with respect to the Combined Software.
//  

// WORK IN PROGRESS, NON-FUNCTIONAL

#include "VulkanInterface.hpp"

template <typename Type> class UniqueHandleTraits;

template <typename Type>
class UniqueHandle : public UniqueHandleTraits<Type>::deleter
{
private:
  using Deleter = typename UniqueHandleTraits<Type>::deleter;
public:
  explicit UniqueHandle(Type const& value = Type(), Deleter const& deleter = Deleter())
    : Deleter(deleter)
    , m_value(value)
  {}

  UniqueHandle(UniqueHandle const&) = delete;

  UniqueHandle(UniqueHandle && other)
    : Deleter(std::move(static_cast<Deleter&>(other)))
    , m_value(other.release())
  {}

  ~UniqueHandle()
  {
    if (m_value) this->destroy(m_value);
  }

  UniqueHandle & operator=(UniqueHandle const&) = delete;

  UniqueHandle & operator=(UniqueHandle && other)
  {
    reset(other.release());
    *static_cast<Deleter*>(this) = std::move(static_cast<Deleter&>(other));
    return *this;
  }

  explicit operator bool() const
  {
    return m_value.operator bool();
  }

  Type const* operator->() const
  {
    return &m_value;
  }

  Type * operator->()
  {
    return &m_value;
  }

  Type const& operator*() const
  {
    return m_value;
  }

  Type & operator*()
  {
    return m_value;
  }

  const Type & get() const
  {
    return m_value;
  }

  Type & get()
  {
    return m_value;
  }

  void reset(Type const& value = Type())
  {
    if (m_value != value)
    {
      if (m_value) this->destroy(m_value);
      m_value = value;
    }
  }

  Type release()
  {
    Type value = m_value;
    m_value = nullptr;
    return value;
  }

  void swap(UniqueHandle<Type> & rhs)
  {
    std::swap(m_value, rhs.m_value);
    std::swap(static_cast<Deleter&>(*this), static_cast<Deleter&>(rhs));
  }

private:
  Type    m_value;
};

template <typename Type>
inline void swap(UniqueHandle<Type> & lhs, UniqueHandle<Type> & rhs)
{
  lhs.swap(rhs);
}

template <typename RefType>
class Optional
{
public:
  Optional(RefType & reference) { m_ptr = &reference; }
  Optional(RefType * ptr) { m_ptr = ptr; }
  Optional(std::nullptr_t) { m_ptr = nullptr; }

  operator RefType*() const { return m_ptr; }
  RefType const* operator->() const { return m_ptr; }
  explicit operator bool() const { return !!m_ptr; }

private:
  RefType *m_ptr;
};

template <typename OwnerType>
class ObjectDestroy
{
public:
  ObjectDestroy(OwnerType owner = OwnerType(), Optional<const VkAllocationCallbacks> allocator = nullptr)
    : m_owner(owner)
    , m_allocator(allocator)
  {}

  OwnerType getOwner() const { return m_owner; }
  Optional<const AllocationCallbacks> getAllocator() const { return m_allocator; }

protected:
  template <typename T>
  void destroy(T t)
  {
    m_owner.destroy(t, m_allocator);
  }

private:
  OwnerType m_owner;
  Optional<const VkAllocationCallbacks> m_allocator;
};

class NoParent;

class ObjectDestroy<NoParent>
{
public:
  ObjectDestroy(Optional<const VkAllocationCallbacks> allocator = nullptr)
    : m_allocator(allocator)
  {}

  Optional<const VkAllocationCallbacks> getAllocator() const { return m_allocator; }

protected:
  template <typename T>
  void destroy(T t)
  {
    t.destroy(m_allocator);
  }

private:
  Optional<const VkAllocationCallbacks> m_allocator;
};

template <typename OwnerType>
class ObjectFree
{
public:
  ObjectFree(OwnerType owner = OwnerType(), Optional<const VkAllocationCallbacks> allocator = nullptr)
    : m_owner(owner)
    , m_allocator(allocator)
  {}

  OwnerType getOwner() const { return m_owner; }
  Optional<const VkAllocationCallbacks> getAllocator() const { return m_allocator; }

protected:
  template <typename T>
  void destroy(T t)
  {
    m_owner.free(t, m_allocator);
  }

private:
  OwnerType m_owner;
  Optional<const VkAllocationCallbacks> m_allocator;
};

template <typename OwnerType, typename PoolType>
class PoolFree
{
public:
  PoolFree(OwnerType owner = OwnerType(), PoolType pool = PoolType())
    : m_owner(owner)
    , m_pool(pool)
  {}

  OwnerType getOwner() const { return m_owner; }
  PoolType getPool() const { return m_pool; }

protected:
  template <typename T>
  void destroy(T t);

private:
  OwnerType m_owner;
  PoolType m_pool;
};

class PoolFree<VkDevice, VkCommandPool>
{
protected:
  template<typename T>
  void Destroy(VkDevice device, T t)
  {
    VulkanInterface::vkFreeCommandBuffers(device, t)
  }
};

class UniqueHandleTraits<VkDebugReportCallbackEXT> { public: using deleter = ObjectDestroy<VkInstance>; };
using UniqueDebugReportCallbackEXT = UniqueHandle<VkDebugReportCallbackEXT>;
class UniqueHandleTraits<VkDebugUtilsMessengerEXT> { public: using deleter = ObjectDestroy<VkInstance>; };
using UniqueDebugUtilsMessengerEXT = UniqueHandle<VkDebugUtilsMessengerEXT>;
class UniqueHandleTraits<VkSurfaceKHR> { public: using deleter = ObjectDestroy<VkInstance>; };
using UniqueSurfaceKHR = UniqueHandle<VkSurfaceKHR>;

class UniqueHandleTraits<VkAccelerationStructureNVX> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueAccelerationStructureNVX = UniqueHandle<VkAccelerationStructureNVX>;
class UniqueHandleTraits<VkBuffer> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueBuffer = UniqueHandle<VkBuffer>;
class UniqueHandleTraits<VkBufferView> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueBufferView = UniqueHandle<VkBufferView>;
class UniqueHandleTraits<VkCommandBuffer> { public: using deleter = PoolFree<VkDevice, VkCommandPool>; };
using UniqueCommandBuffer = UniqueHandle<VkCommandBuffer>;
class UniqueHandleTraits<VkCommandPool> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueCommandPool = UniqueHandle<VkCommandPool>;
class UniqueHandleTraits<VkDescriptorPool> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueDescriptorPool = UniqueHandle<VkDescriptorPool>;
class UniqueHandleTraits<VkDescriptorSet> { public: using deleter = PoolFree<VkDevice, VkDescriptorPool>; };
using UniqueDescriptorSet = UniqueHandle<VkDescriptorSet>;
class UniqueHandleTraits<VkDescriptorSetLayout> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueDescriptorSetLayout = UniqueHandle<VkDescriptorSetLayout>;
class UniqueHandleTraits<VkDescriptorUpdateTemplate> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueDescriptorUpdateTemplate = UniqueHandle<VkDescriptorUpdateTemplate>;
class UniqueHandleTraits<VkDeviceMemory> { public: using deleter = ObjectFree<VkDevice>; };
using UniqueDeviceMemory = UniqueHandle<VkDeviceMemory>;
class UniqueHandleTraits<VkEvent> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueEvent = UniqueHandle<VkEvent>;
class UniqueHandleTraits<VkFence> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueFence = UniqueHandle<VkFence>;
class UniqueHandleTraits<VkFramebuffer> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueFramebuffer = UniqueHandle<VkFramebuffer>;
class UniqueHandleTraits<VkImage> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueImage = UniqueHandle<VkImage>;
class UniqueHandleTraits<VkImageView> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueImageView = UniqueHandle<VkImageView>;
class UniqueHandleTraits<VkIndirectCommandsLayoutNVX> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueIndirectCommandsLayoutNVX = UniqueHandle<VkIndirectCommandsLayoutNVX>;
class UniqueHandleTraits<VkObjectTableNVX> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueObjectTableNVX = UniqueHandle<VkObjectTableNVX>;
class UniqueHandleTraits<VkPipeline> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniquePipeline = UniqueHandle<VkPipeline>;
class UniqueHandleTraits<VkPipelineCache> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniquePipelineCache = UniqueHandle<VkPipelineCache>;
class UniqueHandleTraits<VkPipelineLayout> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniquePipelineLayout = UniqueHandle<VkPipelineLayout>;
class UniqueHandleTraits<VkQueryPool> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueQueryPool = UniqueHandle<VkQueryPool>;
class UniqueHandleTraits<VkRenderPass> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueRenderPass = UniqueHandle<VkRenderPass>;
class UniqueHandleTraits<VkSampler> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueSampler = UniqueHandle<VkSampler>;
class UniqueHandleTraits<VkSamplerYcbcrConversion> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueSamplerYcbcrConversion = UniqueHandle<VkSamplerYcbcrConversion>;
class UniqueHandleTraits<VkSemaphore> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueSemaphore = UniqueHandle<VkSemaphore>;
class UniqueHandleTraits<VkShaderModule> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueShaderModule = UniqueHandle<VkShaderModule>;
class UniqueHandleTraits<VkSwapchainKHR> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueSwapchainKHR = UniqueHandle<VkSwapchainKHR>;
class UniqueHandleTraits<VkValidationCacheEXT> { public: using deleter = ObjectDestroy<VkDevice>; };
using UniqueValidationCacheEXT = UniqueHandle<VkValidationCacheEXT>;
